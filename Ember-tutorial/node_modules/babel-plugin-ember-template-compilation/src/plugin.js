"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePlugin = void 0;
const babel_import_util_1 = require("babel-import-util");
const expression_parser_1 = require("./expression-parser");
const js_utils_1 = require("./js-utils");
const scope_locals_1 = require("./scope-locals");
const syntax_1 = require("@glimmer/syntax");
__exportStar(require("./public-types"), exports);
const INLINE_PRECOMPILE_MODULES = [
    {
        moduleName: 'ember-cli-htmlbars',
        export: 'hbs',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'ember-cli-htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: '@ember/template-compilation',
        export: 'precompileTemplate',
        enableScope: true,
    },
    {
        moduleName: '@ember/template-compiler',
        export: 'template',
        enableScope: true,
        rfc931Support: 'polyfilled',
    },
];
function normalizeOpts(options) {
    var _a;
    if (((_a = options.targetFormat) !== null && _a !== void 0 ? _a : 'wire') === 'wire') {
        let { compiler } = options;
        if (!compiler) {
            throw new Error(`when targetFormat==="wire" you must set the compiler or compilerPath option`);
        }
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'wire', compiler });
    }
    else {
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'hbs' });
    }
}
function makePlugin(loadOptions) {
    return function htmlbarsInlinePrecompile(babel) {
        let t = babel.types;
        const plugin = {
            visitor: {
                Program: {
                    enter(path, state) {
                        state.normalizedOpts = normalizeOpts(loadOptions(state.opts));
                        state.templateFactory = templateFactoryConfig(state.normalizedOpts);
                        state.util = new babel_import_util_1.ImportUtil(babel, path);
                        state.program = path;
                        state.recursionGuard = new Set();
                    },
                    exit(_path, state) {
                        if (state.normalizedOpts.targetFormat === 'wire') {
                            for (let { moduleName, export: exportName } of configuredModules(state)) {
                                state.util.removeImport(moduleName, exportName);
                            }
                        }
                    },
                },
                TaggedTemplateExpression(path, state) {
                    let tagPath = path.get('tag');
                    if (!tagPath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(tagPath, state);
                    if (!config) {
                        return;
                    }
                    if (!config.allowTemplateLiteral) {
                        throw path.buildCodeFrameError(`Attempted to use \`${tagPath.node.name}\` as a template tag, but it can only be called as a function with a string passed to it: ${tagPath.node.name}('content here')`);
                    }
                    if (path.node.quasi.expressions.length) {
                        throw path.buildCodeFrameError('placeholders inside a tagged template string are not supported');
                    }
                    let template = path.node.quasi.quasis.map((quasi) => quasi.value.cooked).join('');
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, {}, config, undefined);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, {}, config, undefined);
                    }
                },
                CallExpression(path, state) {
                    let calleePath = path.get('callee');
                    if (!calleePath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(calleePath, state);
                    if (!config) {
                        return;
                    }
                    if (state.recursionGuard.has(path.node)) {
                        return;
                    }
                    if (path.get('arguments').length > 2) {
                        throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string and any static options`);
                    }
                    let [firstArg, secondArg] = path.get('arguments');
                    let template;
                    switch (firstArg === null || firstArg === void 0 ? void 0 : firstArg.node.type) {
                        case 'StringLiteral':
                            template = firstArg.node.value;
                            break;
                        case 'TemplateLiteral':
                            if (firstArg.node.expressions.length) {
                                throw path.buildCodeFrameError('placeholders inside a template string are not supported');
                            }
                            else {
                                template = firstArg.node.quasis.map((quasi) => quasi.value.cooked).join('');
                            }
                            break;
                        case 'TaggedTemplateExpression':
                            throw path.buildCodeFrameError(`tagged template strings inside ${calleePath.node.name} are not supported`);
                        default:
                            throw path.buildCodeFrameError(`${calleePath.node.name} should be invoked with at least a single argument (the template string)`);
                    }
                    let userTypedOptions;
                    let backingClass;
                    if (!secondArg) {
                        userTypedOptions = {};
                    }
                    else {
                        if (!secondArg.isObjectExpression()) {
                            throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string, and any static options`);
                        }
                        userTypedOptions = new expression_parser_1.ExpressionParser(babel).parseObjectExpression(calleePath.node.name, secondArg, config.enableScope, Boolean(config.rfc931Support));
                        if (config.rfc931Support && userTypedOptions.component) {
                            backingClass = userTypedOptions.component;
                        }
                    }
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, userTypedOptions, config, backingClass);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, userTypedOptions, config, backingClass);
                    }
                },
            },
        };
        return {
            pre(file) {
                // run our processing in pre so that imports for gts
                // are kept for other plugins.
                babel.traverse(file.ast, plugin.visitor, file.scope, this);
            },
            visitor: {},
        };
    };
}
exports.makePlugin = makePlugin;
function* configuredModules(state) {
    for (let moduleConfig of INLINE_PRECOMPILE_MODULES) {
        if (moduleConfig.moduleName !== '@ember/template-compilation' &&
            moduleConfig.moduleName !== '@ember/template-compiler' &&
            !state.normalizedOpts.enableLegacyModules.includes(moduleConfig.moduleName)) {
            continue;
        }
        yield moduleConfig;
    }
}
function referencesInlineCompiler(path, state) {
    for (let moduleConfig of configuredModules(state)) {
        if (path.referencesImport(moduleConfig.moduleName, moduleConfig.export)) {
            return moduleConfig;
        }
    }
    return undefined;
}
function runtimeErrorIIFE(babel, replacements) {
    let statement = babel.template(`(function() {\n  throw new Error('ERROR_MESSAGE');\n})();`)(replacements);
    return statement.expression;
}
function buildScopeLocals(userTypedOptions, formatOptions, target) {
    if (formatOptions.rfc931Support && userTypedOptions.eval) {
        return new scope_locals_1.ScopeLocals({ mode: 'implicit', jsPath: target });
    }
    else if (userTypedOptions.scope) {
        return userTypedOptions.scope;
    }
    else {
        return new scope_locals_1.ScopeLocals({ mode: 'explicit' });
    }
}
function buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scope) {
    let jsutils = new js_utils_1.JSUtils(babel, state, target, scope.add.bind(scope), state.util);
    let meta = Object.assign({ jsutils }, userTypedOptions === null || userTypedOptions === void 0 ? void 0 : userTypedOptions.meta);
    let output = {
        contents: template,
        // we've extended meta to add jsutils, but the types in @glimmer/syntax
        // don't account for extension
        meta: meta,
        // TODO: embroider's template-compiler allows this to be overriden to get
        // backward-compatible module names that don't match the real name of the
        // on-disk file. What's our plan for migrating people away from that?
        moduleName: state.filename,
        // This is here so it's *always* the real filename. Historically, there is
        // also `moduleName` but that did not match the real on-disk filename, it
        // was the notional runtime module name from classic ember builds.
        filename: state.filename,
        plugins: {
            // the cast is needed here only because our meta is extended. That is,
            // these plugins can access meta.jsutils.
            ast: [...state.normalizedOpts.transforms, scope.crawl()],
        },
    };
    for (let [key, value] of Object.entries(userTypedOptions)) {
        if (key !== 'scope') {
            // `scope` in the user-facing API becomes `locals` in the low-level
            // ember-template-compiler API
            output[key] = value;
        }
    }
    output.locals = scope.locals;
    if (config.rfc931Support) {
        output.strictMode = true;
    }
    return output;
}
function remapAndBindIdentifiers(target, babel, scopeLocals) {
    var _a;
    babel.traverse(target.node, {
        Identifier(path) {
            var _a;
            if (scopeLocals.has(path.node.name) && path.node.name !== scopeLocals.get(path.node.name)) {
                // this identifier has different names in hbs vs js, so we need to
                // replace the hbs name in the template compiler output with the js
                // name
                path.replaceWith(babel.types.identifier(scopeLocals.get(path.node.name)));
            }
            // this is where we tell babel's scope system about the new reference we
            // just introduced. @babel/plugin-transform-typescript in particular
            // cares a lot about those references being present.
            (_a = path.scope.getBinding(path.node.name)) === null || _a === void 0 ? void 0 : _a.reference(path);
        },
    }, target.scope, {}, (_a = target.parentPath) !== null && _a !== void 0 ? _a : undefined);
}
function insertCompiledTemplate(babel, state, opts, template, target, userTypedOptions, config, backingClass) {
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, config, target);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scopeLocals);
    let precompileResultString;
    // insertRuntimeErrors is legacy and not supported by the newer rfc931 form
    if (options.insertRuntimeErrors && !config.rfc931Support) {
        try {
            precompileResultString = opts.compiler.precompile(template, options);
        }
        catch (error) {
            target.replaceWith(runtimeErrorIIFE(babel, { ERROR_MESSAGE: error.message }));
            return;
        }
    }
    else {
        precompileResultString = opts.compiler.precompile(template, options);
    }
    let precompileResultAST = babel.parse(`var precompileResult = ${precompileResultString}; `, {
        babelrc: false,
        configFile: false,
    });
    let templateExpression = precompileResultAST.program.body[0]
        .declarations[0].init;
    t.addComment(templateExpression, 'leading', `\n  ${template.replace(/\*\//g, '*\\/')}\n`, 
    /* line comment? */ false);
    state.util.replaceWith(target, (i) => {
        var _a;
        let templateFactoryIdentifier = i.import(state.templateFactory.moduleName, state.templateFactory.exportName);
        let expression = t.callExpression(templateFactoryIdentifier, [templateExpression]);
        if (config.rfc931Support) {
            expression = t.callExpression(i.import('@ember/component', 'setComponentTemplate'), [
                expression,
                (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : t.callExpression(i.import('@ember/component/template-only', 'default', 'templateOnly'), []),
            ]);
        }
        return expression;
    });
    remapAndBindIdentifiers(target, babel, scopeLocals);
}
function insertTransformedTemplate(babel, state, template, target, userTypedOptions, formatOptions, backingClass) {
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, formatOptions, target);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, formatOptions, scopeLocals);
    let ast = (0, syntax_1.preprocess)(template, Object.assign(Object.assign({}, options), { mode: 'codemod' }));
    let transformed = (0, syntax_1.print)(ast, { entityEncoding: 'raw' });
    if (target.isCallExpression()) {
        updateCallForm(target, transformed, formatOptions, scopeLocals, state, babel, backingClass);
    }
    else {
        updateBacktickForm(scopeLocals, state, target, t, transformed, babel);
    }
}
function updateBacktickForm(scopeLocals, state, target, t, transformed, babel) {
    if (scopeLocals.isEmpty()) {
        // simple case: just replace the string literal part with the transformed
        // template contents
        target.get('quasi').get('quasis.0').replaceWith(t.templateElement({ raw: transformed }));
        return;
    }
    // need to add scope, so need to replace the backticks form with a call
    // expression to precompileTemplate
    maybePruneImport(state.util, target.get('tag'));
    let newCall = state.util.replaceWith(target, (i) => t.callExpression(precompileTemplate(i), [t.stringLiteral(transformed)]));
    updateScope(babel, newCall, scopeLocals);
}
function updateCallForm(target, transformed, formatOptions, scopeLocals, state, babel, backingClass) {
    // first the simple part: replacing the string literal with the actual body of
    // the rewritten template
    target.get('arguments.0').replaceWith(babel.types.stringLiteral(transformed));
    if (!formatOptions.enableScope && !scopeLocals.isEmpty()) {
        // an AST transform added lexically scoped values to a template that
        // wasn't already in a form that supports them, so convert form.
        maybePruneImport(state.util, target.get('callee'));
        state.util.replaceWith(target.get('callee'), (i) => precompileTemplate(i));
    }
    if (formatOptions.rfc931Support === 'polyfilled') {
        maybePruneImport(state.util, target.get('callee'));
        state.util.replaceWith(target.get('callee'), (i) => precompileTemplate(i));
        convertStrictMode(babel, target);
        removeEvalAndScope(target);
        target.node.arguments = target.node.arguments.slice(0, 2);
        state.recursionGuard.add(target.node);
        state.util.replaceWith(target, (i) => {
            var _a;
            return babel.types.callExpression(i.import('@ember/component', 'setComponentTemplate'), [
                target.node,
                (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : babel.types.callExpression(i.import('@ember/component/template-only', 'default', 'templateOnly'), []),
            ]);
        });
        // we just wrapped the target callExpression in the call to
        // setComponentTemplate. Adjust `target` back to point at the
        // precompileTemplate call for the final updateScope below.
        //
        target = target.get('arguments.0');
    }
    // We deliberately do updateScope at the end so that when it updates
    // references, those references will point to the accurate paths in the
    // final AST.
    updateScope(babel, target, scopeLocals);
}
function templateFactoryConfig(opts) {
    var _a;
    let moduleName = '@ember/template-factory';
    let exportName = 'createTemplateFactory';
    let overrides = (_a = opts.outputModuleOverrides[moduleName]) === null || _a === void 0 ? void 0 : _a[exportName];
    return overrides
        ? { exportName: overrides[0], moduleName: overrides[1] }
        : { exportName, moduleName };
}
function buildScope(babel, locals) {
    let t = babel.types;
    return t.arrowFunctionExpression([], t.objectExpression(locals
        .entries()
        .map(([name, identifier]) => t.objectProperty(t.identifier(name), t.identifier(identifier), false, true))));
}
// this is responsible both for adjusting the AST for our scope argument *and*
// ensuring that babel's scope system will see that these new identifiers
// reference their bindings. @babel/plugin-transform-typescript in particular
// cares an awful lot about whether an import has valid non-type references, so
// these newly introducd references need to be valid.
function updateScope(babel, target, locals) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let scope = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'scope';
        });
        if (scope) {
            if (locals.isEmpty()) {
                scope.remove();
            }
            else {
                scope.set('value', buildScope(babel, locals));
                // funny-looking naming here, but it actually makes sense because we're
                // connecting the glimmer scope system with the babel scope system.
                scope.scope.crawl();
            }
        }
        else if (!locals.isEmpty()) {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('scope'), buildScope(babel, locals)));
            secondArg.get(`properties.${secondArg.node.properties.length - 1}`).scope.crawl();
        }
    }
    else if (!locals.isEmpty()) {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('scope'), buildScope(babel, locals))]));
        target.get('arguments.1').scope.crawl();
    }
}
function removeEvalAndScope(target) {
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let evalProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'eval';
        });
        if (evalProp) {
            evalProp.remove();
        }
        let componentProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'component';
        });
        if (componentProp) {
            componentProp.remove();
        }
    }
}
// Given a call to template(), convert its "strict" argument into
// precompileTemplate's "strictMode" argument. They differ in name and default
// value.
function convertStrictMode(babel, target) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let strict = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'strict';
        });
        if (strict) {
            strict.set('key', t.identifier('strictMode'));
        }
        else {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true)));
        }
    }
    else {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true))]));
    }
}
function maybePruneImport(util, identifier) {
    if (!identifier.isIdentifier()) {
        return;
    }
    let binding = identifier.scope.getBinding(identifier.node.name);
    if (!binding) {
        return;
    }
    let found = binding.referencePaths.find((path) => path.node === identifier.node);
    if (!found) {
        return;
    }
    binding.referencePaths.splice(binding.referencePaths.indexOf(found), 1);
    binding.references--;
    if (binding.references === 0) {
        let specifier = binding.path;
        if (specifier.isImportSpecifier()) {
            let declaration = specifier.parentPath;
            util.removeImport(declaration.node.source.value, name(specifier.node.imported));
        }
    }
}
function precompileTemplate(i) {
    return i.import('@ember/template-compilation', 'precompileTemplate');
}
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
exports.default = makePlugin((options) => options);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0EseURBQThEO0FBQzlELDJEQUF1RDtBQUN2RCx5Q0FBNEQ7QUFHNUQsaURBQTZDO0FBQzdDLDRDQUFzRTtBQUV0RSxpREFBK0I7QUFZL0IsTUFBTSx5QkFBeUIsR0FBbUI7SUFDaEQ7UUFDRSxVQUFVLEVBQUUsb0JBQW9CO1FBQ2hDLE1BQU0sRUFBRSxLQUFLO1FBQ2Isb0JBQW9CLEVBQUUsSUFBSTtLQUMzQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLHNDQUFzQztRQUNsRCxNQUFNLEVBQUUsU0FBUztRQUNqQixvQkFBb0IsRUFBRSxJQUFJO0tBQzNCO0lBQ0Q7UUFDRSxVQUFVLEVBQUUsNEJBQTRCO1FBQ3hDLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLG9CQUFvQixFQUFFLElBQUk7S0FDM0I7SUFDRDtRQUNFLFVBQVUsRUFBRSw2QkFBNkI7UUFDekMsTUFBTSxFQUFFLG9CQUFvQjtRQUM1QixXQUFXLEVBQUUsSUFBSTtLQUNsQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLDBCQUEwQjtRQUN0QyxNQUFNLEVBQUUsVUFBVTtRQUNsQixXQUFXLEVBQUUsSUFBSTtRQUNqQixhQUFhLEVBQUUsWUFBWTtLQUM1QjtDQUNGLENBQUM7QUErREYsU0FBUyxhQUFhLENBQUMsT0FBZ0I7O0lBQ3JDLElBQUksQ0FBQyxNQUFBLE9BQU8sQ0FBQyxZQUFZLG1DQUFJLE1BQU0sQ0FBQyxLQUFLLE1BQU0sRUFBRTtRQUMvQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzNCLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDYixNQUFNLElBQUksS0FBSyxDQUNiLDZFQUE2RSxDQUM5RSxDQUFDO1NBQ0g7UUFDRCxxQ0FDRSxxQkFBcUIsRUFBRSxFQUFFLEVBQ3pCLG1CQUFtQixFQUFFLEVBQUUsRUFDdkIsVUFBVSxF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QUFvQixDQUFDLENBQUM7QUFDdkUsQ0FBQztBQUVELFNBQVMsSUFBSSxDQUFDLElBQW9DO0lBQ2hELElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxlQUFlLEVBQUU7UUFDakMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0tBQ25CO1NBQU07UUFDTCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7S0FDbEI7QUFDSCxDQUFDO0FBRUQsa0JBQWUsVUFBVSxDQUFVLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTm9kZVBhdGggfSBmcm9tICdAYmFiZWwvdHJhdmVyc2UnO1xuaW1wb3J0IHR5cGUgKiBhcyBCYWJlbCBmcm9tICdAYmFiZWwvY29yZSc7XG5pbXBvcnQgdHlwZSB7IHR5cGVzIGFzIHQgfSBmcm9tICdAYmFiZWwvY29yZSc7XG5pbXBvcnQgeyBJbXBvcnRVdGlsLCB0eXBlIEltcG9ydGVyIH0gZnJvbSAnYmFiZWwtaW1wb3J0LXV0aWwnO1xuaW1wb3J0IHsgRXhwcmVzc2lvblBhcnNlciB9IGZyb20gJy4vZXhwcmVzc2lvbi1wYXJzZXInO1xuaW1wb3J0IHsgSlNVdGlscywgRXh0ZW5kZWRQbHVnaW5CdWlsZGVyIH0gZnJvbSAnLi9qcy11dGlscyc7XG5pbXBvcnQgdHlwZSB7IEVtYmVyVGVtcGxhdGVDb21waWxlciwgUHJlcHJvY2Vzc09wdGlvbnMgfSBmcm9tICcuL2VtYmVyLXRlbXBsYXRlLWNvbXBpbGVyJztcbmltcG9ydCB7IExlZ2FjeU1vZHVsZU5hbWUgfSBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5pbXBvcnQgeyBTY29wZUxvY2FscyB9IGZyb20gJy4vc2NvcGUtbG9jYWxzJztcbmltcG9ydCB7IEFTVFBsdWdpbkJ1aWxkZXIsIHByZXByb2Nlc3MsIHByaW50IH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcblxuZXhwb3J0ICogZnJvbSAnLi9wdWJsaWMtdHlwZXMnO1xuXG50eXBlIE1vZHVsZU5hbWUgPSBMZWdhY3lNb2R1bGVOYW1lIHwgJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbicgfCAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGVyJztcblxuaW50ZXJmYWNlIE1vZHVsZUNvbmZpZyB7XG4gIG1vZHVsZU5hbWU6IE1vZHVsZU5hbWU7XG4gIGV4cG9ydDogc3RyaW5nO1xuICBhbGxvd1RlbXBsYXRlTGl0ZXJhbD86IHRydWU7XG4gIGVuYWJsZVNjb3BlPzogdHJ1ZTtcbiAgcmZjOTMxU3VwcG9ydD86ICdwb2x5ZmlsbGVkJztcbn1cblxuY29uc3QgSU5MSU5FX1BSRUNPTVBJTEVfTU9EVUxFUzogTW9kdWxlQ29uZmlnW10gPSBbXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnZW1iZXItY2xpLWh0bWxiYXJzJyxcbiAgICBleHBvcnQ6ICdoYnMnLFxuICAgIGFsbG93VGVtcGxhdGVMaXRlcmFsOiB0cnVlLFxuICB9LFxuICB7XG4gICAgbW9kdWxlTmFtZTogJ2VtYmVyLWNsaS1odG1sYmFycy1pbmxpbmUtcHJlY29tcGlsZScsXG4gICAgZXhwb3J0OiAnZGVmYXVsdCcsXG4gICAgYWxsb3dUZW1wbGF0ZUxpdGVyYWw6IHRydWUsXG4gIH0sXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnaHRtbGJhcnMtaW5saW5lLXByZWNvbXBpbGUnLFxuICAgIGV4cG9ydDogJ2RlZmF1bHQnLFxuICAgIGFsbG93VGVtcGxhdGVMaXRlcmFsOiB0cnVlLFxuICB9LFxuICB7XG4gICAgbW9kdWxlTmFtZTogJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbicsXG4gICAgZXhwb3J0OiAncHJlY29tcGlsZVRlbXBsYXRlJyxcbiAgICBlbmFibGVTY29wZTogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsZXInLFxuICAgIGV4cG9ydDogJ3RlbXBsYXRlJyxcbiAgICBlbmFibGVTY29wZTogdHJ1ZSxcbiAgICByZmM5MzFTdXBwb3J0OiAncG9seWZpbGxlZCcsXG4gIH0sXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnMge1xuICAvLyBUaGUgZW1iZXItdGVtcGxhdGUtY29tcGlsZXIuanMgbW9kdWxlIHRoYXQgc2hpcHMgd2l0aGluIHlvdXIgZW1iZXItc291cmNlXG4gIC8vIHZlcnNpb24uIE1hbmRhdG9yeSB3aGVuIHVzaW5nIHRhcmdldEZvcm1hdDogJ3dpcmUnLlxuICBjb21waWxlcj86IEVtYmVyVGVtcGxhdGVDb21waWxlcjtcblxuICAvLyBBbGxvd3MgeW91IHRvIHJlbWFwIHdoYXQgaW1wb3J0cyB3aWxsIGJlIGVtaXR0ZWQgaW4gb3VyIGNvbXBpbGVkIG91dHB1dC4gQnlcbiAgLy8gZXhhbXBsZTpcbiAgLy9cbiAgLy8gICBvdXRwdXRNb2R1bGVPdmVycmlkZXM6IHtcbiAgLy8gICAgICdAZW1iZXIvdGVtcGxhdGUtZmFjdG9yeSc6IHtcbiAgLy8gICAgICAgY3JlYXRlVGVtcGxhdGVGYWN0b3J5OiBbJ2NyZWF0ZVRlbXBsYXRlRmFjdG9yeScsICdAZ2xpbW1lci9jb3JlJ10sXG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvL1xuICAvLyBOb3JtYWwgRW1iZXIgYXBwcyBzaG91bGRuJ3QgbmVlZCB0aGlzLCBpdCBleGlzdHMgdG8gc3VwcG9ydCBvdGhlclxuICAvLyBlbnZpcm9ubWVudHMgbGlrZSBzdGFuZGFsb25lIEdsaW1tZXJKU1xuICBvdXRwdXRNb2R1bGVPdmVycmlkZXM/OiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBbc3RyaW5nLCBzdHJpbmddPj47XG5cbiAgLy8gQnkgZGVmYXVsdCwgdGhpcyBwbHVnaW4gaW1wbGVtZW50cyBvbmx5IEVtYmVyJ3Mgc3RhYmxlIHB1YmxpYyBBUEkgZm9yXG4gIC8vIHRlbXBsYXRlIGNvbXBpbGF0aW9uLCB3aGljaCBpczpcbiAgLy9cbiAgLy8gICAgaW1wb3J0IHsgcHJlY29tcGlsZVRlbXBsYXRlIH0gZnJvbSAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGF0aW9uJztcbiAgLy9cbiAgLy8gQnV0IGhpc3RvcmljYWxseSB0aGVyZSBhcmUgc2V2ZXJhbCBvdGhlciBpbXBvcnRhYmxlIHN5bnRheGVzIGluIHdpZGVzcHJlYWRcbiAgLy8gdXNlLCBhbmQgd2UgY2FuIGVuYWJsZSB0aG9zZSB0b28gYnkgaW5jbHVkaW5nIHRoZWlyIG1vZHVsZSBuYW1lcyBpbiB0aGlzXG4gIC8vIGxpc3QuXG4gIGVuYWJsZUxlZ2FjeU1vZHVsZXM/OiBMZWdhY3lNb2R1bGVOYW1lW107XG5cbiAgLy8gQ29udHJvbHMgdGhlIG91dHB1dCBmb3JtYXQuXG4gIC8vXG4gIC8vICBcIndpcmVcIjogVGhlIGRlZmF1bHQuIEluIHRoZSBvdXRwdXQsIHlvdXIgdGVtcGxhdGVzIGFyZSByZWFkeSB0byBleGVjdXRlIGluXG4gIC8vICB0aGUgbW9zdCBwZXJmb3JtYW50IHdheS5cbiAgLy9cbiAgLy8gIFwiaGJzXCI6IEluIHRoZSBvdXRwdXQsIHlvdXIgdGVtcGxhdGVzIHdpbGwgc3RpbGwgYmUgaW4gSEJTIGZvcm1hdC5cbiAgLy8gIEdlbmVyYWxseSB0aGlzIG1lYW5zIHRoZXkgd2lsbCBzdGlsbCBuZWVkIGZ1cnRoZXIgcHJvY2Vzc2luZyBiZWZvcmVcbiAgLy8gIHRoZXkncmUgcmVhZHkgdG8gZXhlY3V0ZS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtb2RlIGlzIHRvIHN1cHBvcnQgdGhpbmdzXG4gIC8vICBsaWtlIGNvZGVtb2RzIGFuZCBwcmUtcHVibGljYXRpb24gdHJhbnNmb3JtYXRpb25zIGluIGxpYnJhcmllcy5cbiAgdGFyZ2V0Rm9ybWF0PzogJ3dpcmUnIHwgJ2hicyc7XG5cbiAgLy8gT3B0aW9uYWwgbGlzdCBvZiBjdXN0b20gdHJhbnNmb3JtcyB0byBhcHBseSB0byB0aGUgaGFuZGxlYmFycyBBU1QgYmVmb3JlXG4gIC8vIGNvbXBpbGF0aW9uLlxuICB0cmFuc2Zvcm1zPzogRXh0ZW5kZWRQbHVnaW5CdWlsZGVyW107XG59XG5cbmludGVyZmFjZSBXaXJlT3B0cyB7XG4gIHRhcmdldEZvcm1hdDogJ3dpcmUnO1xuICBjb21waWxlcjogRW1iZXJUZW1wbGF0ZUNvbXBpbGVyO1xuICBvdXRwdXRNb2R1bGVPdmVycmlkZXM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIFtzdHJpbmcsIHN0cmluZ10+PjtcbiAgZW5hYmxlTGVnYWN5TW9kdWxlczogTGVnYWN5TW9kdWxlTmFtZVtdO1xuICB0cmFuc2Zvcm1zOiBFeHRlbmRlZFBsdWdpbkJ1aWxkZXJbXTtcbn1cblxuaW50ZXJmYWNlIEhic09wdHMge1xuICB0YXJnZXRGb3JtYXQ6ICdoYnMnO1xuICBvdXRwdXRNb2R1bGVPdmVycmlkZXM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIFtzdHJpbmcsIHN0cmluZ10+PjtcbiAgZW5hYmxlTGVnYWN5TW9kdWxlczogTGVnYWN5TW9kdWxlTmFtZVtdO1xuICB0cmFuc2Zvcm1zOiBFeHRlbmRlZFBsdWdpbkJ1aWxkZXJbXTtcbn1cblxudHlwZSBOb3JtYWxpemVkT3B0cyA9IFdpcmVPcHRzIHwgSGJzT3B0cztcblxuZnVuY3Rpb24gbm9ybWFsaXplT3B0cyhvcHRpb25zOiBPcHRpb25zKTogTm9ybWFsaXplZE9wdHMge1xuICBpZiAoKG9wdGlvbnMudGFyZ2V0Rm9ybWF0ID8/ICd3aXJlJykgPT09ICd3aXJlJykge1xuICAgIGxldCB7IGNvbXBpbGVyIH0gPSBvcHRpb25zO1xuICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYHdoZW4gdGFyZ2V0Rm9ybWF0PT09XCJ3aXJlXCIgeW91IG11c3Qgc2V0IHRoZSBjb21waWxlciBvciBjb21waWxlclBhdGggb3B0aW9uYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dE1vZHVsZU92ZXJyaWRlczoge30sXG4gICAgICBlbmFibGVMZWdhY3lNb2R1bGVzOiBbXSxcbiAgICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRhcmdldEZvcm1hdDogJ3dpcmUnLFxuICAgICAgY29tcGlsZXIsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiB7fSxcbiAgICAgIGVuYWJsZUxlZ2FjeU1vZHVsZXM6IFtdLFxuICAgICAgdHJhbnNmb3JtczogW10sXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdGFyZ2V0Rm9ybWF0OiAnaGJzJyxcbiAgICB9O1xuICB9XG59XG5cbmludGVyZmFjZSBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+IHtcbiAgb3B0czogRW52U3BlY2lmaWNPcHRpb25zO1xuICBub3JtYWxpemVkT3B0czogTm9ybWFsaXplZE9wdHM7XG4gIHV0aWw6IEltcG9ydFV0aWw7XG4gIHRlbXBsYXRlRmFjdG9yeTogeyBtb2R1bGVOYW1lOiBzdHJpbmc7IGV4cG9ydE5hbWU6IHN0cmluZyB9O1xuICBwcm9ncmFtOiBOb2RlUGF0aDx0LlByb2dyYW0+O1xuICBsYXN0SW5zZXJ0ZWRQYXRoOiBOb2RlUGF0aDx0LlN0YXRlbWVudD4gfCB1bmRlZmluZWQ7XG4gIGZpbGVuYW1lOiBzdHJpbmc7XG4gIHJlY3Vyc2lvbkd1YXJkOiBTZXQ8dW5rbm93bj47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUGx1Z2luPEVudlNwZWNpZmljT3B0aW9ucz4obG9hZE9wdGlvbnM6IChvcHRzOiBFbnZTcGVjaWZpY09wdGlvbnMpID0+IE9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGh0bWxiYXJzSW5saW5lUHJlY29tcGlsZShcbiAgICBiYWJlbDogdHlwZW9mIEJhYmVsXG4gICk6IEJhYmVsLlBsdWdpbk9iajxTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+PiB7XG4gICAgbGV0IHQgPSBiYWJlbC50eXBlcztcblxuICAgIGNvbnN0IHBsdWdpbiA9IHtcbiAgICAgIHZpc2l0b3I6IHtcbiAgICAgICAgUHJvZ3JhbToge1xuICAgICAgICAgIGVudGVyKHBhdGg6IE5vZGVQYXRoPHQuUHJvZ3JhbT4sIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KSB7XG4gICAgICAgICAgICBzdGF0ZS5ub3JtYWxpemVkT3B0cyA9IG5vcm1hbGl6ZU9wdHMobG9hZE9wdGlvbnMoc3RhdGUub3B0cykpO1xuICAgICAgICAgICAgc3RhdGUudGVtcGxhdGVGYWN0b3J5ID0gdGVtcGxhdGVGYWN0b3J5Q29uZmlnKHN0YXRlLm5vcm1hbGl6ZWRPcHRzKTtcbiAgICAgICAgICAgIHN0YXRlLnV0aWwgPSBuZXcgSW1wb3J0VXRpbChiYWJlbCwgcGF0aCk7XG4gICAgICAgICAgICBzdGF0ZS5wcm9ncmFtID0gcGF0aDtcbiAgICAgICAgICAgIHN0YXRlLnJlY3Vyc2lvbkd1YXJkID0gbmV3IFNldCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXhpdChfcGF0aDogTm9kZVBhdGg8dC5Qcm9ncmFtPiwgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4pIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5ub3JtYWxpemVkT3B0cy50YXJnZXRGb3JtYXQgPT09ICd3aXJlJykge1xuICAgICAgICAgICAgICBmb3IgKGxldCB7IG1vZHVsZU5hbWUsIGV4cG9ydDogZXhwb3J0TmFtZSB9IG9mIGNvbmZpZ3VyZWRNb2R1bGVzKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnV0aWwucmVtb3ZlSW1wb3J0KG1vZHVsZU5hbWUsIGV4cG9ydE5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oXG4gICAgICAgICAgcGF0aDogTm9kZVBhdGg8dC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24+LFxuICAgICAgICAgIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+XG4gICAgICAgICkge1xuICAgICAgICAgIGxldCB0YWdQYXRoID0gcGF0aC5nZXQoJ3RhZycpO1xuXG4gICAgICAgICAgaWYgKCF0YWdQYXRoLmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBjb25maWcgPSByZWZlcmVuY2VzSW5saW5lQ29tcGlsZXIodGFnUGF0aCwgc3RhdGUpO1xuICAgICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjb25maWcuYWxsb3dUZW1wbGF0ZUxpdGVyYWwpIHtcbiAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgYEF0dGVtcHRlZCB0byB1c2UgXFxgJHt0YWdQYXRoLm5vZGUubmFtZX1cXGAgYXMgYSB0ZW1wbGF0ZSB0YWcsIGJ1dCBpdCBjYW4gb25seSBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIHBhc3NlZCB0byBpdDogJHt0YWdQYXRoLm5vZGUubmFtZX0oJ2NvbnRlbnQgaGVyZScpYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aC5ub2RlLnF1YXNpLmV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAncGxhY2Vob2xkZXJzIGluc2lkZSBhIHRhZ2dlZCB0ZW1wbGF0ZSBzdHJpbmcgYXJlIG5vdCBzdXBwb3J0ZWQnXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IHBhdGgubm9kZS5xdWFzaS5xdWFzaXMubWFwKChxdWFzaSkgPT4gcXVhc2kudmFsdWUuY29va2VkKS5qb2luKCcnKTtcbiAgICAgICAgICBpZiAoc3RhdGUubm9ybWFsaXplZE9wdHMudGFyZ2V0Rm9ybWF0ID09PSAnd2lyZScpIHtcbiAgICAgICAgICAgIGluc2VydENvbXBpbGVkVGVtcGxhdGUoXG4gICAgICAgICAgICAgIGJhYmVsLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgc3RhdGUubm9ybWFsaXplZE9wdHMsXG4gICAgICAgICAgICAgIHRlbXBsYXRlLFxuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydFRyYW5zZm9ybWVkVGVtcGxhdGUoYmFiZWwsIHN0YXRlLCB0ZW1wbGF0ZSwgcGF0aCwge30sIGNvbmZpZywgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ2FsbEV4cHJlc3Npb24ocGF0aDogTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj4sIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KSB7XG4gICAgICAgICAgbGV0IGNhbGxlZVBhdGggPSBwYXRoLmdldCgnY2FsbGVlJyk7XG5cbiAgICAgICAgICBpZiAoIWNhbGxlZVBhdGguaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHJlZmVyZW5jZXNJbmxpbmVDb21waWxlcihjYWxsZWVQYXRoLCBzdGF0ZSk7XG4gICAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUucmVjdXJzaW9uR3VhcmQuaGFzKHBhdGgubm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aC5nZXQoJ2FyZ3VtZW50cycpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgYCR7Y2FsbGVlUGF0aC5ub2RlLm5hbWV9IGNhbiBvbmx5IGJlIGludm9rZWQgd2l0aCAyIGFyZ3VtZW50czogdGhlIHRlbXBsYXRlIHN0cmluZyBhbmQgYW55IHN0YXRpYyBvcHRpb25zYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgW2ZpcnN0QXJnLCBzZWNvbmRBcmddID0gcGF0aC5nZXQoJ2FyZ3VtZW50cycpO1xuXG4gICAgICAgICAgbGV0IHRlbXBsYXRlO1xuXG4gICAgICAgICAgc3dpdGNoIChmaXJzdEFyZz8ubm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzpcbiAgICAgICAgICAgICAgdGVtcGxhdGUgPSBmaXJzdEFyZy5ub2RlLnZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RlbXBsYXRlTGl0ZXJhbCc6XG4gICAgICAgICAgICAgIGlmIChmaXJzdEFyZy5ub2RlLmV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgICAgICdwbGFjZWhvbGRlcnMgaW5zaWRlIGEgdGVtcGxhdGUgc3RyaW5nIGFyZSBub3Qgc3VwcG9ydGVkJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBmaXJzdEFyZy5ub2RlLnF1YXNpcy5tYXAoKHF1YXNpKSA9PiBxdWFzaS52YWx1ZS5jb29rZWQpLmpvaW4oJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAgIGB0YWdnZWQgdGVtcGxhdGUgc3RyaW5ncyBpbnNpZGUgJHtjYWxsZWVQYXRoLm5vZGUubmFtZX0gYXJlIG5vdCBzdXBwb3J0ZWRgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgYCR7Y2FsbGVlUGF0aC5ub2RlLm5hbWV9IHNob3VsZCBiZSBpbnZva2VkIHdpdGggYXQgbGVhc3QgYSBzaW5nbGUgYXJndW1lbnQgKHRoZSB0ZW1wbGF0ZSBzdHJpbmcpYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgICBsZXQgYmFja2luZ0NsYXNzOiB1bmRlZmluZWQgfCBOb2RlUGF0aDxQYXJhbWV0ZXJzPHR5cGVvZiB0LmNhbGxFeHByZXNzaW9uPlsxXVtudW1iZXJdPjtcblxuICAgICAgICAgIGlmICghc2Vjb25kQXJnKSB7XG4gICAgICAgICAgICB1c2VyVHlwZWRPcHRpb25zID0ge307XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc2Vjb25kQXJnLmlzT2JqZWN0RXhwcmVzc2lvbigpKSB7XG4gICAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgICBgJHtjYWxsZWVQYXRoLm5vZGUubmFtZX0gY2FuIG9ubHkgYmUgaW52b2tlZCB3aXRoIDIgYXJndW1lbnRzOiB0aGUgdGVtcGxhdGUgc3RyaW5nLCBhbmQgYW55IHN0YXRpYyBvcHRpb25zYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1c2VyVHlwZWRPcHRpb25zID0gbmV3IEV4cHJlc3Npb25QYXJzZXIoYmFiZWwpLnBhcnNlT2JqZWN0RXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgY2FsbGVlUGF0aC5ub2RlLm5hbWUsXG4gICAgICAgICAgICAgIHNlY29uZEFyZyxcbiAgICAgICAgICAgICAgY29uZmlnLmVuYWJsZVNjb3BlLFxuICAgICAgICAgICAgICBCb29sZWFuKGNvbmZpZy5yZmM5MzFTdXBwb3J0KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChjb25maWcucmZjOTMxU3VwcG9ydCAmJiB1c2VyVHlwZWRPcHRpb25zLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICBiYWNraW5nQ2xhc3MgPSB1c2VyVHlwZWRPcHRpb25zLmNvbXBvbmVudCBhcyBOb2RlUGF0aDxcbiAgICAgICAgICAgICAgICBQYXJhbWV0ZXJzPHR5cGVvZiB0LmNhbGxFeHByZXNzaW9uPlsxXVtudW1iZXJdXG4gICAgICAgICAgICAgID47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm5vcm1hbGl6ZWRPcHRzLnRhcmdldEZvcm1hdCA9PT0gJ3dpcmUnKSB7XG4gICAgICAgICAgICBpbnNlcnRDb21waWxlZFRlbXBsYXRlKFxuICAgICAgICAgICAgICBiYWJlbCxcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIHN0YXRlLm5vcm1hbGl6ZWRPcHRzLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgdXNlclR5cGVkT3B0aW9ucyxcbiAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICBiYWNraW5nQ2xhc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydFRyYW5zZm9ybWVkVGVtcGxhdGUoXG4gICAgICAgICAgICAgIGJhYmVsLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIHVzZXJUeXBlZE9wdGlvbnMsXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgYmFja2luZ0NsYXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBwcmUodGhpczogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPiwgZmlsZSkge1xuICAgICAgICAvLyBydW4gb3VyIHByb2Nlc3NpbmcgaW4gcHJlIHNvIHRoYXQgaW1wb3J0cyBmb3IgZ3RzXG4gICAgICAgIC8vIGFyZSBrZXB0IGZvciBvdGhlciBwbHVnaW5zLlxuICAgICAgICBiYWJlbC50cmF2ZXJzZShmaWxlLmFzdCwgcGx1Z2luLnZpc2l0b3IsIGZpbGUuc2NvcGUsIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0b3I6IHt9LFxuICAgIH07XG4gIH0gYXMgKGJhYmVsOiB0eXBlb2YgQmFiZWwpID0+IEJhYmVsLlBsdWdpbk9iajx1bmtub3duPjtcbn1cblxuZnVuY3Rpb24qIGNvbmZpZ3VyZWRNb2R1bGVzPEVudlNwZWNpZmljT3B0aW9ucz4oc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4pIHtcbiAgZm9yIChsZXQgbW9kdWxlQ29uZmlnIG9mIElOTElORV9QUkVDT01QSUxFX01PRFVMRVMpIHtcbiAgICBpZiAoXG4gICAgICBtb2R1bGVDb25maWcubW9kdWxlTmFtZSAhPT0gJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbicgJiZcbiAgICAgIG1vZHVsZUNvbmZpZy5tb2R1bGVOYW1lICE9PSAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGVyJyAmJlxuICAgICAgIXN0YXRlLm5vcm1hbGl6ZWRPcHRzLmVuYWJsZUxlZ2FjeU1vZHVsZXMuaW5jbHVkZXMobW9kdWxlQ29uZmlnLm1vZHVsZU5hbWUpXG4gICAgKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgeWllbGQgbW9kdWxlQ29uZmlnO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZmVyZW5jZXNJbmxpbmVDb21waWxlcjxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICBwYXRoOiBOb2RlUGF0aDx0LklkZW50aWZpZXI+LFxuICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPlxuKTogTW9kdWxlQ29uZmlnIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChsZXQgbW9kdWxlQ29uZmlnIG9mIGNvbmZpZ3VyZWRNb2R1bGVzKHN0YXRlKSkge1xuICAgIGlmIChwYXRoLnJlZmVyZW5jZXNJbXBvcnQobW9kdWxlQ29uZmlnLm1vZHVsZU5hbWUsIG1vZHVsZUNvbmZpZy5leHBvcnQpKSB7XG4gICAgICByZXR1cm4gbW9kdWxlQ29uZmlnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBydW50aW1lRXJyb3JJSUZFKGJhYmVsOiB0eXBlb2YgQmFiZWwsIHJlcGxhY2VtZW50czogeyBFUlJPUl9NRVNTQUdFOiBzdHJpbmcgfSkge1xuICBsZXQgc3RhdGVtZW50ID0gYmFiZWwudGVtcGxhdGUoYChmdW5jdGlvbigpIHtcXG4gIHRocm93IG5ldyBFcnJvcignRVJST1JfTUVTU0FHRScpO1xcbn0pKCk7YCkoXG4gICAgcmVwbGFjZW1lbnRzXG4gICkgYXMgdC5FeHByZXNzaW9uU3RhdGVtZW50O1xuICByZXR1cm4gc3RhdGVtZW50LmV4cHJlc3Npb247XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU2NvcGVMb2NhbHMoXG4gIHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBmb3JtYXRPcHRpb25zOiBNb2R1bGVDb25maWcsXG4gIHRhcmdldDogTm9kZVBhdGg8dC5FeHByZXNzaW9uPlxuKTogU2NvcGVMb2NhbHMge1xuICBpZiAoZm9ybWF0T3B0aW9ucy5yZmM5MzFTdXBwb3J0ICYmIHVzZXJUeXBlZE9wdGlvbnMuZXZhbCkge1xuICAgIHJldHVybiBuZXcgU2NvcGVMb2NhbHMoeyBtb2RlOiAnaW1wbGljaXQnLCBqc1BhdGg6IHRhcmdldCB9KTtcbiAgfSBlbHNlIGlmICh1c2VyVHlwZWRPcHRpb25zLnNjb3BlKSB7XG4gICAgcmV0dXJuIHVzZXJUeXBlZE9wdGlvbnMuc2NvcGUgYXMgU2NvcGVMb2NhbHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBTY29wZUxvY2Fscyh7IG1vZGU6ICdleHBsaWNpdCcgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRQcmVjb21waWxlT3B0aW9uczxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICBiYWJlbDogdHlwZW9mIEJhYmVsLFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuRXhwcmVzc2lvbj4sXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LFxuICB0ZW1wbGF0ZTogc3RyaW5nLFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgY29uZmlnOiBNb2R1bGVDb25maWcsXG4gIHNjb3BlOiBTY29wZUxvY2Fsc1xuKTogUHJlcHJvY2Vzc09wdGlvbnMgJiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIGxldCBqc3V0aWxzID0gbmV3IEpTVXRpbHMoYmFiZWwsIHN0YXRlLCB0YXJnZXQsIHNjb3BlLmFkZC5iaW5kKHNjb3BlKSwgc3RhdGUudXRpbCk7XG4gIGxldCBtZXRhID0gT2JqZWN0LmFzc2lnbih7IGpzdXRpbHMgfSwgdXNlclR5cGVkT3B0aW9ucz8ubWV0YSk7XG5cbiAgbGV0IG91dHB1dDogUHJlcHJvY2Vzc09wdGlvbnMgJiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHtcbiAgICBjb250ZW50czogdGVtcGxhdGUsXG5cbiAgICAvLyB3ZSd2ZSBleHRlbmRlZCBtZXRhIHRvIGFkZCBqc3V0aWxzLCBidXQgdGhlIHR5cGVzIGluIEBnbGltbWVyL3N5bnRheFxuICAgIC8vIGRvbid0IGFjY291bnQgZm9yIGV4dGVuc2lvblxuICAgIG1ldGE6IG1ldGEgYXMgUHJlcHJvY2Vzc09wdGlvbnNbJ21ldGEnXSxcblxuICAgIC8vIFRPRE86IGVtYnJvaWRlcidzIHRlbXBsYXRlLWNvbXBpbGVyIGFsbG93cyB0aGlzIHRvIGJlIG92ZXJyaWRlbiB0byBnZXRcbiAgICAvLyBiYWNrd2FyZC1jb21wYXRpYmxlIG1vZHVsZSBuYW1lcyB0aGF0IGRvbid0IG1hdGNoIHRoZSByZWFsIG5hbWUgb2YgdGhlXG4gICAgLy8gb24tZGlzayBmaWxlLiBXaGF0J3Mgb3VyIHBsYW4gZm9yIG1pZ3JhdGluZyBwZW9wbGUgYXdheSBmcm9tIHRoYXQ/XG4gICAgbW9kdWxlTmFtZTogc3RhdGUuZmlsZW5hbWUsXG5cbiAgICAvLyBUaGlzIGlzIGhlcmUgc28gaXQncyAqYWx3YXlzKiB0aGUgcmVhbCBmaWxlbmFtZS4gSGlzdG9yaWNhbGx5LCB0aGVyZSBpc1xuICAgIC8vIGFsc28gYG1vZHVsZU5hbWVgIGJ1dCB0aGF0IGRpZCBub3QgbWF0Y2ggdGhlIHJlYWwgb24tZGlzayBmaWxlbmFtZSwgaXRcbiAgICAvLyB3YXMgdGhlIG5vdGlvbmFsIHJ1bnRpbWUgbW9kdWxlIG5hbWUgZnJvbSBjbGFzc2ljIGVtYmVyIGJ1aWxkcy5cbiAgICBmaWxlbmFtZTogc3RhdGUuZmlsZW5hbWUsXG5cbiAgICBwbHVnaW5zOiB7XG4gICAgICAvLyB0aGUgY2FzdCBpcyBuZWVkZWQgaGVyZSBvbmx5IGJlY2F1c2Ugb3VyIG1ldGEgaXMgZXh0ZW5kZWQuIFRoYXQgaXMsXG4gICAgICAvLyB0aGVzZSBwbHVnaW5zIGNhbiBhY2Nlc3MgbWV0YS5qc3V0aWxzLlxuICAgICAgYXN0OiBbLi4uc3RhdGUubm9ybWFsaXplZE9wdHMudHJhbnNmb3Jtcywgc2NvcGUuY3Jhd2woKV0gYXMgQVNUUGx1Z2luQnVpbGRlcltdLFxuICAgIH0sXG4gIH07XG5cbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHVzZXJUeXBlZE9wdGlvbnMpKSB7XG4gICAgaWYgKGtleSAhPT0gJ3Njb3BlJykge1xuICAgICAgLy8gYHNjb3BlYCBpbiB0aGUgdXNlci1mYWNpbmcgQVBJIGJlY29tZXMgYGxvY2Fsc2AgaW4gdGhlIGxvdy1sZXZlbFxuICAgICAgLy8gZW1iZXItdGVtcGxhdGUtY29tcGlsZXIgQVBJXG4gICAgICBvdXRwdXRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIG91dHB1dC5sb2NhbHMgPSBzY29wZS5sb2NhbHM7XG5cbiAgaWYgKGNvbmZpZy5yZmM5MzFTdXBwb3J0KSB7XG4gICAgb3V0cHV0LnN0cmljdE1vZGUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gcmVtYXBBbmRCaW5kSWRlbnRpZmllcnModGFyZ2V0OiBOb2RlUGF0aCwgYmFiZWw6IHR5cGVvZiBCYWJlbCwgc2NvcGVMb2NhbHM6IFNjb3BlTG9jYWxzKSB7XG4gIGJhYmVsLnRyYXZlcnNlKFxuICAgIHRhcmdldC5ub2RlLFxuICAgIHtcbiAgICAgIElkZW50aWZpZXIocGF0aDogTm9kZVBhdGg8dC5JZGVudGlmaWVyPikge1xuICAgICAgICBpZiAoc2NvcGVMb2NhbHMuaGFzKHBhdGgubm9kZS5uYW1lKSAmJiBwYXRoLm5vZGUubmFtZSAhPT0gc2NvcGVMb2NhbHMuZ2V0KHBhdGgubm9kZS5uYW1lKSkge1xuICAgICAgICAgIC8vIHRoaXMgaWRlbnRpZmllciBoYXMgZGlmZmVyZW50IG5hbWVzIGluIGhicyB2cyBqcywgc28gd2UgbmVlZCB0b1xuICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGhicyBuYW1lIGluIHRoZSB0ZW1wbGF0ZSBjb21waWxlciBvdXRwdXQgd2l0aCB0aGUganNcbiAgICAgICAgICAvLyBuYW1lXG4gICAgICAgICAgcGF0aC5yZXBsYWNlV2l0aChiYWJlbC50eXBlcy5pZGVudGlmaWVyKHNjb3BlTG9jYWxzLmdldChwYXRoLm5vZGUubmFtZSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIGlzIHdoZXJlIHdlIHRlbGwgYmFiZWwncyBzY29wZSBzeXN0ZW0gYWJvdXQgdGhlIG5ldyByZWZlcmVuY2Ugd2VcbiAgICAgICAgLy8ganVzdCBpbnRyb2R1Y2VkLiBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS10eXBlc2NyaXB0IGluIHBhcnRpY3VsYXJcbiAgICAgICAgLy8gY2FyZXMgYSBsb3QgYWJvdXQgdGhvc2UgcmVmZXJlbmNlcyBiZWluZyBwcmVzZW50LlxuICAgICAgICBwYXRoLnNjb3BlLmdldEJpbmRpbmcocGF0aC5ub2RlLm5hbWUpPy5yZWZlcmVuY2UocGF0aCk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgdGFyZ2V0LnNjb3BlLFxuICAgIHt9LFxuICAgIHRhcmdldC5wYXJlbnRQYXRoID8/IHVuZGVmaW5lZFxuICApO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRDb21waWxlZFRlbXBsYXRlPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIGJhYmVsOiB0eXBlb2YgQmFiZWwsXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LFxuICBvcHRzOiBXaXJlT3B0cyxcbiAgdGVtcGxhdGU6IHN0cmluZyxcbiAgdGFyZ2V0OiBOb2RlUGF0aDx0LkV4cHJlc3Npb24+LFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgY29uZmlnOiBNb2R1bGVDb25maWcsXG4gIGJhY2tpbmdDbGFzczogTm9kZVBhdGg8UGFyYW1ldGVyczx0eXBlb2YgdC5jYWxsRXhwcmVzc2lvbj5bMV1bbnVtYmVyXT4gfCB1bmRlZmluZWRcbikge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICBsZXQgc2NvcGVMb2NhbHMgPSBidWlsZFNjb3BlTG9jYWxzKHVzZXJUeXBlZE9wdGlvbnMsIGNvbmZpZywgdGFyZ2V0KTtcbiAgbGV0IG9wdGlvbnMgPSBidWlsZFByZWNvbXBpbGVPcHRpb25zKFxuICAgIGJhYmVsLFxuICAgIHRhcmdldCxcbiAgICBzdGF0ZSxcbiAgICB0ZW1wbGF0ZSxcbiAgICB1c2VyVHlwZWRPcHRpb25zLFxuICAgIGNvbmZpZyxcbiAgICBzY29wZUxvY2Fsc1xuICApO1xuXG4gIGxldCBwcmVjb21waWxlUmVzdWx0U3RyaW5nOiBzdHJpbmc7XG5cbiAgLy8gaW5zZXJ0UnVudGltZUVycm9ycyBpcyBsZWdhY3kgYW5kIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIG5ld2VyIHJmYzkzMSBmb3JtXG4gIGlmIChvcHRpb25zLmluc2VydFJ1bnRpbWVFcnJvcnMgJiYgIWNvbmZpZy5yZmM5MzFTdXBwb3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHByZWNvbXBpbGVSZXN1bHRTdHJpbmcgPSBvcHRzLmNvbXBpbGVyLnByZWNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0YXJnZXQucmVwbGFjZVdpdGgocnVudGltZUVycm9ySUlGRShiYWJlbCwgeyBFUlJPUl9NRVNTQUdFOiAoZXJyb3IgYXMgYW55KS5tZXNzYWdlIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJlY29tcGlsZVJlc3VsdFN0cmluZyA9IG9wdHMuY29tcGlsZXIucHJlY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBsZXQgcHJlY29tcGlsZVJlc3VsdEFTVCA9IGJhYmVsLnBhcnNlKGB2YXIgcHJlY29tcGlsZVJlc3VsdCA9ICR7cHJlY29tcGlsZVJlc3VsdFN0cmluZ307IGAsIHtcbiAgICBiYWJlbHJjOiBmYWxzZSxcbiAgICBjb25maWdGaWxlOiBmYWxzZSxcbiAgfSkgYXMgdC5GaWxlO1xuXG4gIGxldCB0ZW1wbGF0ZUV4cHJlc3Npb24gPSAocHJlY29tcGlsZVJlc3VsdEFTVC5wcm9ncmFtLmJvZHlbMF0gYXMgdC5WYXJpYWJsZURlY2xhcmF0aW9uKVxuICAgIC5kZWNsYXJhdGlvbnNbMF0uaW5pdCBhcyB0LkV4cHJlc3Npb247XG5cbiAgdC5hZGRDb21tZW50KFxuICAgIHRlbXBsYXRlRXhwcmVzc2lvbixcbiAgICAnbGVhZGluZycsXG4gICAgYFxcbiAgJHt0ZW1wbGF0ZS5yZXBsYWNlKC9cXCpcXC8vZywgJypcXFxcLycpfVxcbmAsXG4gICAgLyogbGluZSBjb21tZW50PyAqLyBmYWxzZVxuICApO1xuXG4gIHN0YXRlLnV0aWwucmVwbGFjZVdpdGgodGFyZ2V0LCAoaSkgPT4ge1xuICAgIGxldCB0ZW1wbGF0ZUZhY3RvcnlJZGVudGlmaWVyID0gaS5pbXBvcnQoXG4gICAgICBzdGF0ZS50ZW1wbGF0ZUZhY3RvcnkubW9kdWxlTmFtZSxcbiAgICAgIHN0YXRlLnRlbXBsYXRlRmFjdG9yeS5leHBvcnROYW1lXG4gICAgKTtcblxuICAgIGxldCBleHByZXNzaW9uID0gdC5jYWxsRXhwcmVzc2lvbih0ZW1wbGF0ZUZhY3RvcnlJZGVudGlmaWVyLCBbdGVtcGxhdGVFeHByZXNzaW9uXSk7XG5cbiAgICBpZiAoY29uZmlnLnJmYzkzMVN1cHBvcnQpIHtcbiAgICAgIGV4cHJlc3Npb24gPSB0LmNhbGxFeHByZXNzaW9uKGkuaW1wb3J0KCdAZW1iZXIvY29tcG9uZW50JywgJ3NldENvbXBvbmVudFRlbXBsYXRlJyksIFtcbiAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgYmFja2luZ0NsYXNzPy5ub2RlID8/XG4gICAgICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICAgIGkuaW1wb3J0KCdAZW1iZXIvY29tcG9uZW50L3RlbXBsYXRlLW9ubHknLCAnZGVmYXVsdCcsICd0ZW1wbGF0ZU9ubHknKSxcbiAgICAgICAgICAgIFtdXG4gICAgICAgICAgKSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfSk7XG5cbiAgcmVtYXBBbmRCaW5kSWRlbnRpZmllcnModGFyZ2V0LCBiYWJlbCwgc2NvcGVMb2NhbHMpO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRUcmFuc2Zvcm1lZFRlbXBsYXRlPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIGJhYmVsOiB0eXBlb2YgQmFiZWwsXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LFxuICB0ZW1wbGF0ZTogc3RyaW5nLFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+IHwgTm9kZVBhdGg8dC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24+LFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgZm9ybWF0T3B0aW9uczogTW9kdWxlQ29uZmlnLFxuICBiYWNraW5nQ2xhc3M6IE5vZGVQYXRoPFBhcmFtZXRlcnM8dHlwZW9mIHQuY2FsbEV4cHJlc3Npb24+WzFdW251bWJlcl0+IHwgdW5kZWZpbmVkXG4pIHtcbiAgbGV0IHQgPSBiYWJlbC50eXBlcztcbiAgbGV0IHNjb3BlTG9jYWxzID0gYnVpbGRTY29wZUxvY2Fscyh1c2VyVHlwZWRPcHRpb25zLCBmb3JtYXRPcHRpb25zLCB0YXJnZXQpO1xuICBsZXQgb3B0aW9ucyA9IGJ1aWxkUHJlY29tcGlsZU9wdGlvbnMoXG4gICAgYmFiZWwsXG4gICAgdGFyZ2V0LFxuICAgIHN0YXRlLFxuICAgIHRlbXBsYXRlLFxuICAgIHVzZXJUeXBlZE9wdGlvbnMsXG4gICAgZm9ybWF0T3B0aW9ucyxcbiAgICBzY29wZUxvY2Fsc1xuICApO1xuICBsZXQgYXN0ID0gcHJlcHJvY2Vzcyh0ZW1wbGF0ZSwgeyAuLi5vcHRpb25zLCBtb2RlOiAnY29kZW1vZCcgfSk7XG4gIGxldCB0cmFuc2Zvcm1lZCA9IHByaW50KGFzdCwgeyBlbnRpdHlFbmNvZGluZzogJ3JhdycgfSk7XG5cbiAgaWYgKHRhcmdldC5pc0NhbGxFeHByZXNzaW9uKCkpIHtcbiAgICB1cGRhdGVDYWxsRm9ybTxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICAgICAgdGFyZ2V0LFxuICAgICAgdHJhbnNmb3JtZWQsXG4gICAgICBmb3JtYXRPcHRpb25zLFxuICAgICAgc2NvcGVMb2NhbHMsXG4gICAgICBzdGF0ZSxcbiAgICAgIGJhYmVsLFxuICAgICAgYmFja2luZ0NsYXNzXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVCYWNrdGlja0Zvcm08RW52U3BlY2lmaWNPcHRpb25zPihzY29wZUxvY2Fscywgc3RhdGUsIHRhcmdldCwgdCwgdHJhbnNmb3JtZWQsIGJhYmVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVCYWNrdGlja0Zvcm08RW52U3BlY2lmaWNPcHRpb25zPihcbiAgc2NvcGVMb2NhbHM6IFNjb3BlTG9jYWxzLFxuICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPixcbiAgdGFyZ2V0OiBOb2RlUGF0aDx0LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbj4sXG4gIHQ6IHR5cGVvZiBCYWJlbC50eXBlcyxcbiAgdHJhbnNmb3JtZWQ6IHN0cmluZyxcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbFxuKSB7XG4gIGlmIChzY29wZUxvY2Fscy5pc0VtcHR5KCkpIHtcbiAgICAvLyBzaW1wbGUgY2FzZToganVzdCByZXBsYWNlIHRoZSBzdHJpbmcgbGl0ZXJhbCBwYXJ0IHdpdGggdGhlIHRyYW5zZm9ybWVkXG4gICAgLy8gdGVtcGxhdGUgY29udGVudHNcbiAgICAodGFyZ2V0LmdldCgncXVhc2knKS5nZXQoJ3F1YXNpcy4wJykgYXMgTm9kZVBhdGg8dC5UZW1wbGF0ZUVsZW1lbnQ+KS5yZXBsYWNlV2l0aChcbiAgICAgIHQudGVtcGxhdGVFbGVtZW50KHsgcmF3OiB0cmFuc2Zvcm1lZCB9KVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gbmVlZCB0byBhZGQgc2NvcGUsIHNvIG5lZWQgdG8gcmVwbGFjZSB0aGUgYmFja3RpY2tzIGZvcm0gd2l0aCBhIGNhbGxcbiAgLy8gZXhwcmVzc2lvbiB0byBwcmVjb21waWxlVGVtcGxhdGVcbiAgbWF5YmVQcnVuZUltcG9ydChzdGF0ZS51dGlsLCB0YXJnZXQuZ2V0KCd0YWcnKSk7XG4gIGxldCBuZXdDYWxsID0gc3RhdGUudXRpbC5yZXBsYWNlV2l0aCh0YXJnZXQsIChpKSA9PlxuICAgIHQuY2FsbEV4cHJlc3Npb24ocHJlY29tcGlsZVRlbXBsYXRlKGkpLCBbdC5zdHJpbmdMaXRlcmFsKHRyYW5zZm9ybWVkKV0pXG4gICk7XG4gIHVwZGF0ZVNjb3BlKGJhYmVsLCBuZXdDYWxsLCBzY29wZUxvY2Fscyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxGb3JtPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIHRhcmdldDogTm9kZVBhdGg8QmFiZWwudHlwZXMuQ2FsbEV4cHJlc3Npb24+LFxuICB0cmFuc2Zvcm1lZDogc3RyaW5nLFxuICBmb3JtYXRPcHRpb25zOiBNb2R1bGVDb25maWcsXG4gIHNjb3BlTG9jYWxzOiBTY29wZUxvY2FscyxcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sXG4gIGJhYmVsOiB0eXBlb2YgQmFiZWwsXG4gIGJhY2tpbmdDbGFzczpcbiAgICB8IE5vZGVQYXRoPEJhYmVsLnR5cGVzLkV4cHJlc3Npb24gfCBCYWJlbC50eXBlcy5Bcmd1bWVudFBsYWNlaG9sZGVyIHwgQmFiZWwudHlwZXMuU3ByZWFkRWxlbWVudD5cbiAgICB8IHVuZGVmaW5lZFxuKSB7XG4gIC8vIGZpcnN0IHRoZSBzaW1wbGUgcGFydDogcmVwbGFjaW5nIHRoZSBzdHJpbmcgbGl0ZXJhbCB3aXRoIHRoZSBhY3R1YWwgYm9keSBvZlxuICAvLyB0aGUgcmV3cml0dGVuIHRlbXBsYXRlXG4gICh0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMCcpIGFzIE5vZGVQYXRoPHQuTm9kZT4pLnJlcGxhY2VXaXRoKFxuICAgIGJhYmVsLnR5cGVzLnN0cmluZ0xpdGVyYWwodHJhbnNmb3JtZWQpXG4gICk7XG5cbiAgaWYgKCFmb3JtYXRPcHRpb25zLmVuYWJsZVNjb3BlICYmICFzY29wZUxvY2Fscy5pc0VtcHR5KCkpIHtcbiAgICAvLyBhbiBBU1QgdHJhbnNmb3JtIGFkZGVkIGxleGljYWxseSBzY29wZWQgdmFsdWVzIHRvIGEgdGVtcGxhdGUgdGhhdFxuICAgIC8vIHdhc24ndCBhbHJlYWR5IGluIGEgZm9ybSB0aGF0IHN1cHBvcnRzIHRoZW0sIHNvIGNvbnZlcnQgZm9ybS5cbiAgICBtYXliZVBydW5lSW1wb3J0KHN0YXRlLnV0aWwsIHRhcmdldC5nZXQoJ2NhbGxlZScpKTtcbiAgICBzdGF0ZS51dGlsLnJlcGxhY2VXaXRoKHRhcmdldC5nZXQoJ2NhbGxlZScpLCAoaSkgPT4gcHJlY29tcGlsZVRlbXBsYXRlKGkpKTtcbiAgfVxuXG4gIGlmIChmb3JtYXRPcHRpb25zLnJmYzkzMVN1cHBvcnQgPT09ICdwb2x5ZmlsbGVkJykge1xuICAgIG1heWJlUHJ1bmVJbXBvcnQoc3RhdGUudXRpbCwgdGFyZ2V0LmdldCgnY2FsbGVlJykpO1xuICAgIHN0YXRlLnV0aWwucmVwbGFjZVdpdGgodGFyZ2V0LmdldCgnY2FsbGVlJyksIChpKSA9PiBwcmVjb21waWxlVGVtcGxhdGUoaSkpO1xuICAgIGNvbnZlcnRTdHJpY3RNb2RlKGJhYmVsLCB0YXJnZXQpO1xuICAgIHJlbW92ZUV2YWxBbmRTY29wZSh0YXJnZXQpO1xuICAgIHRhcmdldC5ub2RlLmFyZ3VtZW50cyA9IHRhcmdldC5ub2RlLmFyZ3VtZW50cy5zbGljZSgwLCAyKTtcbiAgICBzdGF0ZS5yZWN1cnNpb25HdWFyZC5hZGQodGFyZ2V0Lm5vZGUpO1xuICAgIHN0YXRlLnV0aWwucmVwbGFjZVdpdGgodGFyZ2V0LCAoaSkgPT5cbiAgICAgIGJhYmVsLnR5cGVzLmNhbGxFeHByZXNzaW9uKGkuaW1wb3J0KCdAZW1iZXIvY29tcG9uZW50JywgJ3NldENvbXBvbmVudFRlbXBsYXRlJyksIFtcbiAgICAgICAgdGFyZ2V0Lm5vZGUsXG4gICAgICAgIGJhY2tpbmdDbGFzcz8ubm9kZSA/P1xuICAgICAgICAgIGJhYmVsLnR5cGVzLmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgICAgaS5pbXBvcnQoJ0BlbWJlci9jb21wb25lbnQvdGVtcGxhdGUtb25seScsICdkZWZhdWx0JywgJ3RlbXBsYXRlT25seScpLFxuICAgICAgICAgICAgW11cbiAgICAgICAgICApLFxuICAgICAgXSlcbiAgICApO1xuICAgIC8vIHdlIGp1c3Qgd3JhcHBlZCB0aGUgdGFyZ2V0IGNhbGxFeHByZXNzaW9uIGluIHRoZSBjYWxsIHRvXG4gICAgLy8gc2V0Q29tcG9uZW50VGVtcGxhdGUuIEFkanVzdCBgdGFyZ2V0YCBiYWNrIHRvIHBvaW50IGF0IHRoZVxuICAgIC8vIHByZWNvbXBpbGVUZW1wbGF0ZSBjYWxsIGZvciB0aGUgZmluYWwgdXBkYXRlU2NvcGUgYmVsb3cuXG4gICAgLy9cbiAgICB0YXJnZXQgPSB0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMCcpIGFzIE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+O1xuICB9XG4gIC8vIFdlIGRlbGliZXJhdGVseSBkbyB1cGRhdGVTY29wZSBhdCB0aGUgZW5kIHNvIHRoYXQgd2hlbiBpdCB1cGRhdGVzXG4gIC8vIHJlZmVyZW5jZXMsIHRob3NlIHJlZmVyZW5jZXMgd2lsbCBwb2ludCB0byB0aGUgYWNjdXJhdGUgcGF0aHMgaW4gdGhlXG4gIC8vIGZpbmFsIEFTVC5cbiAgdXBkYXRlU2NvcGUoYmFiZWwsIHRhcmdldCwgc2NvcGVMb2NhbHMpO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZUZhY3RvcnlDb25maWcob3B0czogTm9ybWFsaXplZE9wdHMpIHtcbiAgbGV0IG1vZHVsZU5hbWUgPSAnQGVtYmVyL3RlbXBsYXRlLWZhY3RvcnknO1xuICBsZXQgZXhwb3J0TmFtZSA9ICdjcmVhdGVUZW1wbGF0ZUZhY3RvcnknO1xuICBsZXQgb3ZlcnJpZGVzID0gb3B0cy5vdXRwdXRNb2R1bGVPdmVycmlkZXNbbW9kdWxlTmFtZV0/LltleHBvcnROYW1lXTtcbiAgcmV0dXJuIG92ZXJyaWRlc1xuICAgID8geyBleHBvcnROYW1lOiBvdmVycmlkZXNbMF0sIG1vZHVsZU5hbWU6IG92ZXJyaWRlc1sxXSB9XG4gICAgOiB7IGV4cG9ydE5hbWUsIG1vZHVsZU5hbWUgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRTY29wZShiYWJlbDogdHlwZW9mIEJhYmVsLCBsb2NhbHM6IFNjb3BlTG9jYWxzKSB7XG4gIGxldCB0ID0gYmFiZWwudHlwZXM7XG5cbiAgcmV0dXJuIHQuYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oXG4gICAgW10sXG4gICAgdC5vYmplY3RFeHByZXNzaW9uKFxuICAgICAgbG9jYWxzXG4gICAgICAgIC5lbnRyaWVzKClcbiAgICAgICAgLm1hcCgoW25hbWUsIGlkZW50aWZpZXJdKSA9PlxuICAgICAgICAgIHQub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKG5hbWUpLCB0LmlkZW50aWZpZXIoaWRlbnRpZmllciksIGZhbHNlLCB0cnVlKVxuICAgICAgICApXG4gICAgKVxuICApO1xufVxuXG4vLyB0aGlzIGlzIHJlc3BvbnNpYmxlIGJvdGggZm9yIGFkanVzdGluZyB0aGUgQVNUIGZvciBvdXIgc2NvcGUgYXJndW1lbnQgKmFuZCpcbi8vIGVuc3VyaW5nIHRoYXQgYmFiZWwncyBzY29wZSBzeXN0ZW0gd2lsbCBzZWUgdGhhdCB0aGVzZSBuZXcgaWRlbnRpZmllcnNcbi8vIHJlZmVyZW5jZSB0aGVpciBiaW5kaW5ncy4gQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tdHlwZXNjcmlwdCBpbiBwYXJ0aWN1bGFyXG4vLyBjYXJlcyBhbiBhd2Z1bCBsb3QgYWJvdXQgd2hldGhlciBhbiBpbXBvcnQgaGFzIHZhbGlkIG5vbi10eXBlIHJlZmVyZW5jZXMsIHNvXG4vLyB0aGVzZSBuZXdseSBpbnRyb2R1Y2QgcmVmZXJlbmNlcyBuZWVkIHRvIGJlIHZhbGlkLlxuZnVuY3Rpb24gdXBkYXRlU2NvcGUoYmFiZWw6IHR5cGVvZiBCYWJlbCwgdGFyZ2V0OiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPiwgbG9jYWxzOiBTY29wZUxvY2Fscykge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICBsZXQgc2Vjb25kQXJnID0gdGFyZ2V0LmdldCgnYXJndW1lbnRzLjEnKSBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+IHwgdW5kZWZpbmVkO1xuICBpZiAoc2Vjb25kQXJnKSB7XG4gICAgbGV0IHNjb3BlID0gc2Vjb25kQXJnLmdldCgncHJvcGVydGllcycpLmZpbmQoKHApID0+IHtcbiAgICAgIGxldCBrZXkgPSBwLmdldCgna2V5JykgYXMgTm9kZVBhdGg8dC5Ob2RlPjtcbiAgICAgIHJldHVybiBrZXkuaXNJZGVudGlmaWVyKCkgJiYga2V5Lm5vZGUubmFtZSA9PT0gJ3Njb3BlJztcbiAgICB9KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIGlmIChsb2NhbHMuaXNFbXB0eSgpKSB7XG4gICAgICAgIHNjb3BlLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGUuc2V0KCd2YWx1ZScsIGJ1aWxkU2NvcGUoYmFiZWwsIGxvY2FscykpO1xuICAgICAgICAvLyBmdW5ueS1sb29raW5nIG5hbWluZyBoZXJlLCBidXQgaXQgYWN0dWFsbHkgbWFrZXMgc2Vuc2UgYmVjYXVzZSB3ZSdyZVxuICAgICAgICAvLyBjb25uZWN0aW5nIHRoZSBnbGltbWVyIHNjb3BlIHN5c3RlbSB3aXRoIHRoZSBiYWJlbCBzY29wZSBzeXN0ZW0uXG4gICAgICAgIHNjb3BlLnNjb3BlLmNyYXdsKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghbG9jYWxzLmlzRW1wdHkoKSkge1xuICAgICAgc2Vjb25kQXJnLnB1c2hDb250YWluZXIoXG4gICAgICAgICdwcm9wZXJ0aWVzJyxcbiAgICAgICAgdC5vYmplY3RQcm9wZXJ0eSh0LmlkZW50aWZpZXIoJ3Njb3BlJyksIGJ1aWxkU2NvcGUoYmFiZWwsIGxvY2FscykpXG4gICAgICApO1xuICAgICAgKFxuICAgICAgICBzZWNvbmRBcmcuZ2V0KFxuICAgICAgICAgIGBwcm9wZXJ0aWVzLiR7c2Vjb25kQXJnLm5vZGUucHJvcGVydGllcy5sZW5ndGggLSAxfWBcbiAgICAgICAgKSBhcyBOb2RlUGF0aDx0Lk9iamVjdFByb3BlcnR5PlxuICAgICAgKS5zY29wZS5jcmF3bCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghbG9jYWxzLmlzRW1wdHkoKSkge1xuICAgIHRhcmdldC5wdXNoQ29udGFpbmVyKFxuICAgICAgJ2FyZ3VtZW50cycsXG4gICAgICB0Lm9iamVjdEV4cHJlc3Npb24oW3Qub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKCdzY29wZScpLCBidWlsZFNjb3BlKGJhYmVsLCBsb2NhbHMpKV0pXG4gICAgKTtcbiAgICAodGFyZ2V0LmdldCgnYXJndW1lbnRzLjEnKSBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+KS5zY29wZS5jcmF3bCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2YWxBbmRTY29wZSh0YXJnZXQ6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+KSB7XG4gIGxldCBzZWNvbmRBcmcgPSB0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMScpIGFzIE5vZGVQYXRoPHQuT2JqZWN0RXhwcmVzc2lvbj4gfCB1bmRlZmluZWQ7XG4gIGlmIChzZWNvbmRBcmcpIHtcbiAgICBsZXQgZXZhbFByb3AgPSBzZWNvbmRBcmcuZ2V0KCdwcm9wZXJ0aWVzJykuZmluZCgocCkgPT4ge1xuICAgICAgbGV0IGtleSA9IHAuZ2V0KCdrZXknKSBhcyBOb2RlUGF0aDx0Lk5vZGU+O1xuICAgICAgcmV0dXJuIGtleS5pc0lkZW50aWZpZXIoKSAmJiBrZXkubm9kZS5uYW1lID09PSAnZXZhbCc7XG4gICAgfSk7XG4gICAgaWYgKGV2YWxQcm9wKSB7XG4gICAgICBldmFsUHJvcC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBsZXQgY29tcG9uZW50UHJvcCA9IHNlY29uZEFyZy5nZXQoJ3Byb3BlcnRpZXMnKS5maW5kKChwKSA9PiB7XG4gICAgICBsZXQga2V5ID0gcC5nZXQoJ2tleScpIGFzIE5vZGVQYXRoPHQuTm9kZT47XG4gICAgICByZXR1cm4ga2V5LmlzSWRlbnRpZmllcigpICYmIGtleS5ub2RlLm5hbWUgPT09ICdjb21wb25lbnQnO1xuICAgIH0pO1xuICAgIGlmIChjb21wb25lbnRQcm9wKSB7XG4gICAgICBjb21wb25lbnRQcm9wLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBHaXZlbiBhIGNhbGwgdG8gdGVtcGxhdGUoKSwgY29udmVydCBpdHMgXCJzdHJpY3RcIiBhcmd1bWVudCBpbnRvXG4vLyBwcmVjb21waWxlVGVtcGxhdGUncyBcInN0cmljdE1vZGVcIiBhcmd1bWVudC4gVGhleSBkaWZmZXIgaW4gbmFtZSBhbmQgZGVmYXVsdFxuLy8gdmFsdWUuXG5mdW5jdGlvbiBjb252ZXJ0U3RyaWN0TW9kZShiYWJlbDogdHlwZW9mIEJhYmVsLCB0YXJnZXQ6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+KSB7XG4gIGxldCB0ID0gYmFiZWwudHlwZXM7XG4gIGxldCBzZWNvbmRBcmcgPSB0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMScpIGFzIE5vZGVQYXRoPHQuT2JqZWN0RXhwcmVzc2lvbj4gfCB1bmRlZmluZWQ7XG4gIGlmIChzZWNvbmRBcmcpIHtcbiAgICBsZXQgc3RyaWN0ID0gc2Vjb25kQXJnLmdldCgncHJvcGVydGllcycpLmZpbmQoKHApID0+IHtcbiAgICAgIGxldCBrZXkgPSBwLmdldCgna2V5JykgYXMgTm9kZVBhdGg8dC5Ob2RlPjtcbiAgICAgIHJldHVybiBrZXkuaXNJZGVudGlmaWVyKCkgJiYga2V5Lm5vZGUubmFtZSA9PT0gJ3N0cmljdCc7XG4gICAgfSkgYXMgTm9kZVBhdGg8dC5PYmplY3RQcm9wZXJ0eT47XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgc3RyaWN0LnNldCgna2V5JywgdC5pZGVudGlmaWVyKCdzdHJpY3RNb2RlJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWNvbmRBcmcucHVzaENvbnRhaW5lcihcbiAgICAgICAgJ3Byb3BlcnRpZXMnLFxuICAgICAgICB0Lm9iamVjdFByb3BlcnR5KHQuaWRlbnRpZmllcignc3RyaWN0TW9kZScpLCB0LmJvb2xlYW5MaXRlcmFsKHRydWUpKVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnB1c2hDb250YWluZXIoXG4gICAgICAnYXJndW1lbnRzJyxcbiAgICAgIHQub2JqZWN0RXhwcmVzc2lvbihbdC5vYmplY3RQcm9wZXJ0eSh0LmlkZW50aWZpZXIoJ3N0cmljdE1vZGUnKSwgdC5ib29sZWFuTGl0ZXJhbCh0cnVlKSldKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVQcnVuZUltcG9ydChcbiAgdXRpbDogSW1wb3J0VXRpbCxcbiAgaWRlbnRpZmllcjogTm9kZVBhdGg8dC5FeHByZXNzaW9uIHwgdC5WOEludHJpbnNpY0lkZW50aWZpZXI+XG4pIHtcbiAgaWYgKCFpZGVudGlmaWVyLmlzSWRlbnRpZmllcigpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBiaW5kaW5nID0gaWRlbnRpZmllci5zY29wZS5nZXRCaW5kaW5nKGlkZW50aWZpZXIubm9kZS5uYW1lKTtcblxuICBpZiAoIWJpbmRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgZm91bmQgPSBiaW5kaW5nLnJlZmVyZW5jZVBhdGhzLmZpbmQoKHBhdGgpID0+IHBhdGgubm9kZSA9PT0gaWRlbnRpZmllci5ub2RlKTtcbiAgaWYgKCFmb3VuZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGJpbmRpbmcucmVmZXJlbmNlUGF0aHMuc3BsaWNlKGJpbmRpbmcucmVmZXJlbmNlUGF0aHMuaW5kZXhPZihmb3VuZCksIDEpO1xuICBiaW5kaW5nLnJlZmVyZW5jZXMtLTtcblxuICBpZiAoYmluZGluZy5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgbGV0IHNwZWNpZmllciA9IGJpbmRpbmcucGF0aDtcbiAgICBpZiAoc3BlY2lmaWVyLmlzSW1wb3J0U3BlY2lmaWVyKCkpIHtcbiAgICAgIGxldCBkZWNsYXJhdGlvbiA9IHNwZWNpZmllci5wYXJlbnRQYXRoIGFzIE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+O1xuICAgICAgdXRpbC5yZW1vdmVJbXBvcnQoZGVjbGFyYXRpb24ubm9kZS5zb3VyY2UudmFsdWUsIG5hbWUoc3BlY2lmaWVyLm5vZGUuaW1wb3J0ZWQpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlY29tcGlsZVRlbXBsYXRlKGk6IEltcG9ydGVyKSB7XG4gIHJldHVybiBpLmltcG9ydCgnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGF0aW9uJywgJ3ByZWNvbXBpbGVUZW1wbGF0ZScpO1xufVxuXG5mdW5jdGlvbiBuYW1lKG5vZGU6IHQuU3RyaW5nTGl0ZXJhbCB8IHQuSWRlbnRpZmllcikge1xuICBpZiAobm9kZS50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1ha2VQbHVnaW48T3B0aW9ucz4oKG9wdGlvbnMpID0+IG9wdGlvbnMpO1xuIl19